Class {
	#name : #ReHabParkManager,
	#superclass : #CMAgent,
	#instVars : [
		'zones',
		'reserve',
		'logFile',
		'strategy'
	],
	#category : #'ReHab-Model'
}

{ #category : #'default value' }
ReHabParkManager class >> mySpaceUnits_default [
	"Return the default value of mySpaceUnits attribute"
	^nil
]

{ #category : #'default value' }
ReHabParkManager class >> strategy_default [
	"Return the default value of attribute #strategy : nil.
	This method was automatically generated by Cormas.
	!! BECAREFUL, You should not modify this method as it can be generated again when changing the value (Sensitivity Analysis for ex) !!"

	^nil
]

{ #category : #'parameter unit' }
ReHabParkManager class >> strategy_type [
	"Return the type of attribute #strategy.
	This method was automatically generated by Cormas.
	!! BECAREFUL, You should not modify this method as it can be generated again when changing the value (Sensitivity Analysis for ex) !!"

	^UndefinedObject
]

{ #category : #'default value' }
ReHabParkManager class >> zones_default [
	"Return the default value of attribute #zones : OrderedCollection new.
	!! This method was automatically generated by Cormas !!"

	^ OrderedCollection new
]

{ #category : #'default value' }
ReHabParkManager class >> zones_type [
	"Return the type of attribute #zones.
	!! This method was automatically generated by Cormas !!"

	^Collection
]

{ #category : #control }
ReHabParkManager >> decideAccess [
	| zone |
	self strategy getLocations
		do: [ :n | 
			zone := self zones detect: [ :c | c id = n ] ifNone: [ nil ].
			zone ifNotNil: [ zone access: false ] ]
]

{ #category : #control }
ReHabParkManager >> getAccessDecisionsAutonomous [

	(Cormas
		selectRandomlyFrom: self zones
		subCollectionSize: (Cormas randomFrom: 0 to: 3))
		do: [:zone | zone access: false]
]

{ #category : #control }
ReHabParkManager >> getAccessDecisionsFromFileRound: anInteger [
	| stream roundFound info line round zone |
	anInteger > 1 ifTrue: [stream := self logFile readStream.
	roundFound := false.
	info := ''.
	[roundFound not and: [stream atEnd not]] whileTrue:
			[line := (stream upTo: Character cr) tokensBasedOn: Character tab.
			round := line first asNumber.
			info := line last.
			roundFound := round = anInteger].
	stream close.
	(roundFound and: [info isEmpty not])
		ifTrue:
			[(info tokensBasedOn: $;) do:
					[:s |
					s isEmpty
						ifFalse:
							[zone := self zones detect: [:c | c id = s asNumber] ifNone: [nil].
							zone notNil ifTrue: [zone access: false]]]]]
]

{ #category : #control }
ReHabParkManager >> getAccessDecisionsFromPlayersRound: anInteger [

	| npString ids zone collec |
	npString := UIManager default
		            request: 'Parc manager decisions\(Enter id numbers of zones to be protected, separated by space) ' withCRs
		            initialAnswer: ''.

	ids := (npString findTokens: Character space) collect: #asNumber.
	"ids size > 3 ifTrue: [Dialog warn: '3 zones max!'. ^self getAccessDecisionsFromPlayersRound: anInteger]."
	collec := Set new.
	ids do: [ :n | 
		zone := self zones detect: [ :c | c id = n ] ifNone: [ nil ].
		zone ifNotNil: [ 
			zone access: false.
			collec add: zone ] ].
	self logBannedSpaceUnits: collec round: anInteger
]

{ #category : #log }
ReHabParkManager >> logBannedSpaceUnits: aSet round: anInteger [

	self logFile writeStreamDo: [ : stream | 
		stream
			nextPutAll: anInteger printString;
			nextPutAll: '	'.
		aSet do: [ :aSU | 
			stream
				nextPutAll: aSU id printString;
				nextPutAll: ';' ].
		stream nextPutAll: '\' withCRs ]
]

{ #category : #accessing }
ReHabParkManager >> logFile [
	^ logFile
		ifNil: [ logFile := 'bannedLocations.txt' asFileReference ]
]

{ #category : #accessing }
ReHabParkManager >> logFile: x [
	logFile := x
]

{ #category : #accessing }
ReHabParkManager >> reserve [
	"Getter accessor without default value "
	^reserve ifNil: [reserve := Set new].
]

{ #category : #accessing }
ReHabParkManager >> reserve: x [
	reserve := x
]

{ #category : #accessing }
ReHabParkManager >> strategy [
	"Getter accessor without initial value "
	^strategy
]

{ #category : #accessing }
ReHabParkManager >> strategy: aUndefinedObject [
	"Setter accessor of attribute strategy	This method was automatically generated by Cormas.
	!! BECAREFUL, You should not modify this method as it can be generated again when changing the value (Sensitivity Analysis for ex) !!  "
	strategy := aUndefinedObject
]

{ #category : #accessing }
ReHabParkManager >> zones [
	"Getter accessor with initial value = OrderedCollection new.
	!! This method was automatically generated by Cormas !! "

	^ zones ifNil: [ zones := OrderedCollection new ]
]

{ #category : #accessing }
ReHabParkManager >> zones: anObject [
	zones := anObject
]
